# 테스트 가능한 코드 구조란?
테스트를 진행할떄 대부분의 경우 실제 프로덕션 코드의 객체 또는 메서드를 대상으로 테스트를 진행하게 됩니다. 그래서 실제 프로덕션 코드를 작성할때도 테스트 가능한 설계와 구조를 가져가는게 중요하다고 합니다. 이러한 설계 구조를 생각하면서 코드를 설계하면 프로그램의 확장성과 유연성을 확보하면서 테스트도 쉽게 작성할 수 있게됩니다.

테스트 가능한 코드 구조를 생각하기전에 어떤 경우가 테스트가 어려운지 생각해보는게 더 와닿을 것 같아서 테스트가 어려운 구조를 먼저 생각하고 어떻게 해결하는지 알아봤습니다.

## 순수함수를 사용하자
순수함수는 함수형 프로그래밍에 자주 등장하는 단어인데요 순수함수란 외부의 상태에도 의존하지 않고 변경도 하지않는 함수입니다. 즉 `"동일한 입력에 대해서 항상 동일한 결과를 출력"` 하는 함수입니다. 

순수함수를 사용해야 하는 이유는 너무나도 당연합니다. 외부에 상태를 의존하면 우리가 원하는 상황에서의 테스트가 어려워지기 때문입니다.

아주 간단한 예시로 주말기간에 상품할인을 하는 함수가 있다고 가정을 해보겠습니다

상품가격을 받고 주말인지를 판단해서 만약 주말이라면 프로모션이 적용된 가격을 반환합니다. 아마 테스트를 고려하지 않고 코드를 작성하면
아래와같은 방식으로 간단하게 코드를 작성할 가능성도 있습니다.
```swift
func applyPromotionPrice(_ price: Double) -> Double {
        let calendar = Calendar.current
        let today = Date()
        let isWeekend = calendar.isDateInWeekend(today)
        return isWeekend ? price * 0.9 : price
    }
```

만약 테스트를 진행한다고 가정하면 아래와같이 테스트 시나리오를 작성해서 진행하겠죠 하지만 이대로 테스트를 진행한다면 주말에만 테스트를 통과하는 어이없는 상황이 발생합니다.
우리가 테스트 하려는 부분은 주말에 프로모션 가격이 적용되는지 여부이지만 내부의 Date 객체가 날짜라는 외부환경에 영향을 받게되면서 테스트가 깨지게 되는거죠
```swift
 func test_applyPromotionPrice_onWeekend() {
        // Give
        // 유저가 상품을 고른 상황
        let product = Product(productName: "Test Item", price: 10000)
        
        // When
        // 프로모션 가격 적용
        let afterPromotionPrice = sut.applyPromotionPrice(product.price)
        
        // Then
        // 정상적으로 할인가가 적용되었는지 비교
        let expectedPrice = product.price * 0.9
        XCTAssertEqual(expectedPrice, afterPromotionPrice, "할인가가 적용되지 않음")
    }
```

이러한 상황을 만들지 않기위해서 해당 함수를 외부에 영향을 받지않는 순수함수로 만들어야 합니다. 아래의 코드처럼 날짜를 파라미터로 주입받으면
테스트코드를 작성할때 주말인 객체를 넘겨주고 테스트가 가능해집니다.
```swift
func applyPromotionPrice(_ price: Double, date: Date) -> Double {
        let calendar = Calendar.current
        let isWeekend = calendar.isDateInWeekend(date)
        return isWeekend ? price * 0.9 : price
    }
```
하지만 실제 프로덕션 환경에서는 문제없이 동작하는데 일일히 date를 넘겨줘야하는 불편함이 있을 수 있는데요 그럴떄는 디폴트 파라미터를 정해주거나, Test객체를 별도로 생성해서 문제를 해결합니다.
```swift
  func applyPromotionPrice(_ price: Double, date: Date = .now) -> Double {
        let calendar = Calendar.current
        let isWeekend = calendar.isDateInWeekend(date)
        return isWeekend ? price * 0.9 : price
    }
```

```swift
// 프로덕션코드에서 호출시 date 생략
applyPromotionPrice(1000)
```
또한 테스트로부터 외부세계를 분리하는것도 중요하다고 합니다. 예를들어 DB에 데이터를 적재하는 함수가 있다고 가정할때 테스트와 외부환경을 분리하지 않는다면 테스트를 돌릴때마다 DB에 데이터가 추가되는 어이없는 상황이 발생할 수 있습니다.
이러한 문제를 해결하기 위해서 Mock객체를 사용하거나 InMemoryDB를 활용할 수 있습니다.

## 의존성 역전 원칙
의존성 역전 원칙으로 구체타입이 아닌 추상화타입에 의존하게해서 Mock, Stub 객체로 교체하면 테스트합니다.

# 의존성 주입(DI)
의존성 주입이란 객체 내부에서 의존성을 생성하지 않고 생성자를 통해서 객체가 어떤 의존성을 사용할지 정해주는것을 의미합니다. 

- 객체 내부에서 생성
```swift
class UserService {
    let database: MySQLDatabase
    
    init() {
        database = MySQLDatabase()
    }
}
```

- 의존성 주입
```swift
class UserService {
    let database: MySQLDatabase
    
    init(database: MySQLDatabase) {
        self.database = database
    }
}

UserService(database: MySQLDatabase())
```
## 의존성 주입이 필요한 이유?
의존성 주입은 소비자가 의존성을 제공하도록 코드의 구조를 잡는것을 의미한다고 합니다. 그렇다면 의존성 주입은 왜 하는것이며 어떤점이 좋은걸까요?
사실 명확하게 "의존성 주입" 자체는 위에서 말한것처럼 객체를 초기화할때 명시적으로 의존성을 받도록 코드의 구조를 잡는것에 불과하기에 거의 DIP를 염두하고 설명합니다.

### 의존성 역전 원칙(Dependency Inversion Principle)이란?
SOLID 원칙중에 하나에 해당하는게 의존성 역전 원칙 입니다. 
의존성 역전 원칙이란 상위모듈이 하위모듈을 참조할때 추상성이 낮은 인터페이스보다 추상성이 높은 인터페이스를 의존하게 만드는것을 의미합니다.

추상성이 낮다는것은 구체화가 되었다는것을 의미하기에 구체클래스를 의미합니다. 반대로 추상성이 높다는것은 인터페이스를 의미합니다.

예를들어 UserService가 외부서버와 통신하는 APIService라는 구체클래스를 사용하는데 더이상 서버와 통신이 필요없다고 판단되어 내부 로컬디비로 바꾸려고 한다면
APIService라는 구체클래스를 변경된 클래스로 바꿔주고 그 과정에서 다른 메서드에 변경사항을 모두 수정해줘야할 수 있습니다.
여기서 구체클래스가 아닌 추상클래스에 의존하게 만들어야 합니다.

```swift
class UserService {
    private let apiService: APIService
    
    init(apiService: APIService) {
        self.apiService = apiService
    }
    
    func loadUser() {
       apiService.fetchUserData()
    }
}
```

UserDataSource 프로토콜을 선언해주고 로컬디비를 사용할 CoreDataStorage가 해당 프로토콜을 채택하게 해줍니다.
만약 다시 기획이 바뀌더라도 내부의 코드수정없이 UserDataSource를 채택한 객체를 주입해줄 수 있습니다.
```swift
protocol UserDataSource {
    func fetchUserData() -> String
}

class CoreDataStorage: UserDataSource {
    func fetchUserData() -> String {
        return "유저데이터"
    }
}
```

```markdown
기존 의존성 방향
UserServce -> APIService
변경 후 의존성 방향
UserService -> UserDataSource(Protocol) <- CoreDataStorage
```

추가적으로 테스트와 연관지어 보자면 테스트할때 구현된 클래스가 아닌 MockStorage를 주입하여 테스트를 진행할 수 있습니다.
```swift
UserService(dataSource: MockDataStorage())
```

# 테스트 더블(Mocks, Stubs)
테스트 더블이란 실제 객체를 사용하여 테스트하는 방법을 지칭합니다. 위에서도 테스트를 진행할때 외부와 테스트환경은 분리가 필요하다고 설명을 했었는데 만약 테스트를 진행하는데
실제 메일이 전송되거나 DB에 데이터가 적재되는 어이없는 상황이 발생할 수 있습니다. 그걸 방지하기 위해 테스트 더블 객체를 만들고 분리된 환경에서 정확한 테스트가 필요합니다.

저는 Mock이랑 Stub을 중점적으로 알아봤습니다!

## 테스트 더블 종류
- Dummy
- Fake
- Spy
- Stub
- Mock

### Stub
미리 준비된 결과를 리턴합니다. 단순히 "테스트코드 스터디" 라는 결과를 리턴해주는게 목적입니다. 평소에 Mock이라고 알고있던게 사실은 Stub 이었네요
```swift
class StubAPIClient {
    func fetchData() -> String {
        return "테스트코드 스터디"
    }
}

// 테스트 코드에서
let stub = StubAPIClient()
XCTAssertEqual(stub.fetchData(), "테스트코드 스터디")
```
### Mock
Stub과 달리 Mock은 특정 메서드의 동작이 정상적으로 이루어졌는지를 확인하는 방법입니다. 단순히 데이터를 리턴하는 Stub과 다르게 Mock은 정확히 메서드가 한번 호출되었는지를 확인합니다.
조금 헷갈리는데 Stub은 데이터중심 Mock은 행위중심 이렇게 정리할 수 있을 것 같습니다.
```swift
class MockAPIClient {
    var callCount = 0
    
    func fetchData() {
        callCount += 1
    }
}

let mock = MockAPIClient()
mock.fetchData()
XCTAssertEqual(mock.callCount, 1)
```



# References
- [의존성 주입에 대한 오해와 진실](https://soojin.ro/blog/dependency-injection-basics)
- [테스트하기 좋은 코드 - 테스트하기 어려운 코드](https://jojoldu.tistory.com/674)
- [모바일 앱의 느슨한 결합](https://soojin.ro/blog/loose-coupling)
- [Test Double 이란?](https://velog.io/@yisuho/Test-Double-%EC%9D%B4%EB%9E%80)
- [iOS 개발자의 쉽게 쓰는 테스트코드, TDD의 생활화(1)-구조와 방식](https://medium.com/bejewel/ios-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EC%89%BD%EA%B2%8C-%EC%93%B0%EB%8A%94-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C-tdd%EC%9D%98-%EC%83%9D%ED%99%9C%ED%99%94-1-%EA%B5%AC%EC%A1%B0%EC%99%80-%EB%B0%A9%EC%8B%9D-c5609aa8b886)

