## 1. 의존성 주입(DI: Dependency Injection)

### 1) '의존성'이란 무엇일까?

✅ **한 객체가 다른 객체에 의존하는 것**

🎈**예시 코드**
```
class Engine {
    func start() {
        print("엔진을 가동합니다")
    }
}

class Car {
    let engine = Engine()

    func move() {
        engine.start()
        print("차가 출발합니다")
    }
}
```

🎈**위 코드의 문제점은 무엇일까요?**

- 만약 엔진이 아니라 다른 방법으로 시동을 거는 자동차라면? -> Car 클래스를 고쳐야 함

<br>

### 2) '의존성 주입'이란 무엇일까?

✅ 객체 내에서 외부 객체를 생성하지 않음

✅ 외부에서 생성한 객체를 주입하는 것

🎈**프로퍼티 주입**
```
class Engine {
    func start() {
        print("엔진을 가동합니다")
    }
}

class Car {
    var engine = Engine?

    func move() {
        engine?.start()
        print("차가 출발합니다")
    }
}

let car = Car()
let newEngine = Engine()

car.engine = newEngine
car.move()
```

🎈**메서드 주입**
```
class Engine {
    func start() {
        print("엔진을 가동합니다")
    }
}

class Car {
    func move(engine: Engine) {
        engine.start()
        print("차가 출발합니다")
    }
}

let car = Car()
let newEngine = Engine()

car.move(newEngine)
```

🎈**프로퍼티 주입 & 메서드 주입의 문제점**

- 의존하는 객체가 먼저 생성되지 않은 경우에는 이용할 수 없음

🎈**생성자 주입**
```
class Engine {
    func start() {
        print("엔진을 가동합니다")
    }
}

class Car {
    private let engine: Engine

    init(engine: Engine) {
        self.engine = engine
    }
    
    func move() {
        engine.start()
        print("차가 출발합니다")
    }
}

let newEngine = Engine()
let car = Car(engine: newEngine)

car.move()
```

🎈**인터페이스 주입**
```
protocol EngineProtocol {
    func start()
}

class Gasoline: EngineProtocol {
    func start() {
        print("가솔린 엔진 가동")
    }
}

class ElectricMotor: EngineProtocol {
    func start() {
        print("전기 모터 가동")
    }
}

class Car {
    private let engine: EngineProtocol

    init(engine: EngineProtocol) {
        self.engine = engine
    }
    
    func move() {
        engine.start()
        print("차가 출발합니다")
    }
}

let gasoline = Gasoline()
let electric = ElectricMotor()

let car1 = Car(engine: gasoline)
let car2 = Car(engine: electric)

car1.move()
car2.move()
```

---
## 2. 테스트 가능한 코드 구조

### 1) 예시와 함께 알아보는 테스트 가능한 코드 구조

✅ **변경이 용이 / 명확한 동작 분리 / 자동화된 테스트 가능**

🎈**예시 코드 (잘못된 예시)**
```
class CarRacing {
    // 랜덤 값이 4이상이면 자동차가 전진한다고 가정
    func isPossibleMove() -> Bool {
        let move = Int.random(in: 1...10)
        if move >= 4 {
            return true
        }
        return false
    }
}

import XCTest
@testable import Heoseungjun

final class CarRacingTest: XCTestCase {
    func testIsPossibleMove() -> Bool {
        let carRacing = CarRacing()
        let result = carRacing.isPossibleMove()
        XCTAssertTrue(result)
    }
}
```

🎈**예시 코드 (올바른 예시 : 동작 분리)**
```
class CarRacing {
    func isPossibleMove(move: Int) -> Bool {
        if move >= 4 {
            return true
        }
        return false
    }
}

import XCTest
@testable import Heoseungjun

final class CarRacingTest: XCTestCase {
    func testIsPossibleMove() -> Bool {
        let carRacing = CarRacing()
        let result = carRacing.isPossibleMove(4)
        XCTAssertTrue(result)
    }
}
```
<br><br>
### 2) 테스트하기 어려운 코드란 무엇일까?

✅ **싱글톤이 남용되는 경우**

🎈 **싱글톤 남용**

```
class APIService {
    static let shared = APIService()

    func fetchData() -> String {
        return "데이터"
    }
}

class ViewModel {
    func load() -> String {
        return APIService.shared.fetchData()
    }
}
```

🎈 **프로토콜과 의존성 주입 활용**

- 뒤에서 자세히 알아보자!

<br>

✅ **전역 상태를 사용하는 경우**

🎈 **전역 상태 사용**

- 테스트 간 상태가 공유되므로 '테스트 독립성'을 보장할 수 없다
- 병렬 테스트 시 예기치 못한 오류 발생 가능성


```
var currentUserName = "Guest"  // 전역 변수

class Greeting {
    func sayHello() -> String {
        return "Hello, \(currentUserName)"
    }
}
```

🎈 **이렇게 고쳐보자**

```
class Greeting {
    private let userName: String

    init(userName: String) {
        self.userName = userName
    }

    func sayHello() -> String {
        return "Hello, \(userName)"
    }
}
```

<br>

✅ **뷰와 로직이 결합된 경우**

🎈 **뷰와 로직의 결합**

- 단위 테스트 불가 -> UI 테스트를 꼭 함께 진행해야 함

```
class ViewController: UIViewController {
    @IBOutlet weak var label: UILabel!

    override func viewDidLoad() {
        super.viewDidLoad()
        let result = complexLogic()
        label.text = result
    }

    func complexLogic() -> String {
        return "결과"
    }
}
```

🎈 **이렇게 고쳐보자**

- ViewModel 도입
```
class ViewModel {
    func computeResult() -> String {
        return "결과"
    }
}

class ViewController: UIViewController {
    @IBOutlet weak var label: UILabel!
    private let viewModel = ViewModel()

    override func viewDidLoad() {
        super.viewDidLoad()
        label.text = viewModel.computeResult()
    }
}
```


<br><br>

### 3) 테스트 가능한 코드 구조의 핵심 원칙

✅ 단일 책임 원칙

🎈객체는 **단 하나의 책임**만 가져야 한다<br>
🎈평가 척도 : 기능 수정 시 파급 효과<br>
🎈즉, 단일 책임 원칙은 모듈이 변경되는 이유가 1가지여야 한다는 것!

- 참고자료 : https://inpa.tistory.com/entry/OOP-💠-아주-쉽게-이해하는-SRP-단일-책임-원칙#

<br>

✅ SOLID 원칙

🎈S : 단일 책임 원칙
  - 이미 다루었죠?

🎈O : 개방-폐쇄 원칙
  - 소프트웨어 개체는 확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다
  - 개방-폐쇄 원칙 위반 사례 
    ```
    enum 게임 {
        case 스포츠게임
        case FPS게임
    }

    class Flag {
        let 게임유형: 게임
    
        init(게임유형: 게임) {
            self.게임유형 = 게임유형
        }
    }

    func printNameOf게임(flag: Flag) {
        switch flag.게임유형 {
            case .스포츠게임:
                print("FIFA")
            case .아케이드게임:
                print("크레이지아케이드")
        }
    }
    ```

  - 이렇게 바꿔보자
    ```
    protocol 게임 {
        var name: String { get }
    }

    struct 스포츠게임: 게임 {
        let name = "FIFA 온라인"
    }

    class Flag {
        let 게임유형: 게임
        
        init(게임유형: 게임) {
            self.게임유형 = 게임유형
        }
    }
    
    func printNameOf게임(flag: Flag) {
        print(flag.게임유형.name)
    }
    ```

🎈L : 리스코프 치환 원칙
  - 프로그램의 객체는 프로그램 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
  - 자식 클래스는 부모 클래스의 동작을 바꾸지 않는다

🎈I : 인터페이스 분리 원칙
  - 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 말아야 한다
  - 클래스 내에서 사용하지 않는 인터페이스는 구현하지 않는다
  - 예시 코드
    ```
    protocol TapGestureProtocol {
        func 탭()
    }

    protocol LongTapGestureProtocol {
        func 꾸욱누르기()
    }

    protocol DoubleTapGestureProtocol {
        func 더블탭()
    }
    
    class GestureBtn: TapGestureProtocol, LongTapGestureProtocol, DoubleTapGestureProtocol {
        func 탭() {}
        func 꾸욱누르기() {}
        func 더블탭() {}
    }
    
    class DoubleTapBtn: GestureProtocol {
        func 더블탭() {}
    }
    
    class LongAndTapBtn: LongTapGestureProtocol, TapGestureProtocol {
        func 탭() {}
        func 꾸욱누르기() {}
    }
    
    func doSomething(button: DoubleTapGestureProtocol & LongTapGestureProtocol) {
        button.더블탭()
        button.꾸욱누르기()
    }
    ```


🎈D : 의존 역전 원칙
  - 상위 모듈은 하위 모듈에 의존해서는 안 된다
  - 상위 모듈과 하위 모듈 모두 추상화된 인터페이스(프로토콜)에 의존해야 한다
  - 예시 코드

---
## 3. 테스트 더블 (Mocks, Stubs)
