# 4주차

# TDD 사이클 (Red-Green-Refactor)

---

**TDD (Test-Driven Development)** 는 **테스트 주도 개발**이라고 하며, 테스트 코드를 먼저 작성한 뒤 실제 기능을 구현하는 개발 방식입니다. 

단위 테스트를 기반으로 작은 단위의 기능을 반복적으로 구현하고 개선합니다.

그리고 TDD는 Red Green Refactor의 사이클을 순회하는 방식으로 개발이 진행됩니다.

![스크린샷 2025-05-25 오후 7.00.56.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%201fef1d8047c1802cbfc4f2665451dd74/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-05-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.00.56.png)

그중에서 첫번째인 

## 1) Red: 실패하는 테스트 작성

Red는 말 그대로 실패하는 테스트를 작성하는 단계입니다. 

<aside>
❓

엥? 실패하는 테스트??? 왜 쓰지????

</aside>

하지만 이 단계는 소프트웨어 개발이 **수학이 아닌 ‘과학’에 가깝다**는 점과 깊이 연결되어 있습니다.

과학은 연역적인게 아니라 귀납적이잖아요!

이 실패하는 테스트의 목적은

**새로운 기능을 명확하게 정의한다**

- 테스트는 **명세서(To-do 리스트)** 역할을 합니다. 테스트를 정의해놓고, 개발을 하면 빼먹지 않고 개발을 할수 있겠죠??
- 어떤 기능이 어떤 방식으로 동작해야 하는지를 코드로 명확하게 기술합니다. 실제로 만들어질걸 가정하고, 만들기 때문이죠!

**테스트 자체가 제대로 작동하는지를 검증한다**

- 일부러 실패하는 테스트를 통해, **테스트가 신뢰할 수 있는지** 확인합니다.
- 테스트가 **실패**하는 건 오히려 반가운 일이에요 저희가 의도한거죠.근데 잘못된 테스트가 **성공해버린다??** 위험하네요,, 이래서 의존성을 잘 분리해야합니다. 엄청난 사이드 이팩트 현상이 나타나버리니까요

**‘무엇을 원하는가’에 집중하여 인터페이스를 설계한다**

- 함수 이름, 파라미터, 반환 타입 등을 **사용자 관점**에서 먼저 고민하고 정의할 수 있습니다.

이렇게 크게 3가지의 목적이 있습니다. 

예시를 보면서 Red사이클에서는 어떤식으로 테스트를 작성해야하는지 알아봅시다

가장 기본적으로 계산기 프로그램을 만든다고 가정해볼게요.

계산기에는 크게 

- 더하기
- 나누기
- 빼기
- 결과 (=)

이런 기능들이 있어야합니다. 이렇게 필요한 기능을 명확하게 정의 하는것부터 Red 사이클은 시작하게 됩니다.

그후 이제 본격적으로 테스트 코드를 작성합니다.

```swift
func test_add_two_numbers_should_return_sum() {
    let result = Calculator().add(2, 3)
    XCTAssertEqual(result, 5)
}
```

계산기 객체의 add에 접근해서, 해당 함수를 테스트 하는 간단한 예시입니다. 그러나 저희는 아직 계산기 객체의 add()라는 함수를 만들지 않았죠??

테스트를 하면서 아 이기능이 여기에 필요하겠다 그러면 이런이런 값들을 넘겨줘야겠네~! 하는 이런 일종의 명세서 같은 역할을 하게됩니다. 

그리고 당연하게도 이 테스트는 실패하겠죠 , 그러나 실패를 통해서 저희는 이 테스트가 틀린 테스트는 아니구나는 역설적으로 증명하게 됩니다 

이렇게 프로그램에 대한 기본적인 구조와 명세를 구체화하는 Red 단계 이후에 구현에 가까운 단계로 넘어가게 됩니다

## 2) Green: 테스트를 통과하는 최소한의 구현

앞서 기본 골격들의 위치를 설정했다면 골격을 세우는 단계입니다. 

Red 단계에서 무엇을 해야 하는지(기능의 명세)를 테스트 코드로 명확히 정의했다면, Green 단계는 그 테스트를 **통과시키기 위한 가장 최소한의 구현**을 작성하는 단계입니다.

이 단계의 핵심은 **완벽한 구현이 아니라, 오직 테스트를 통과시키는 것**입니다.

Green의 핵심 목적은

- **테스트를 통과시키는 것만을 목표로 한다**
    - 기능 전체가 아닌, 테스트가 요구하는 **구체적인 입력/출력 사례**만 만족
    - 복잡한 예외 처리나 일반화된 로직은 이 단계에서 고려하지 않고 오직 테스트 통과에만 초점을 맞춰야해요
- **속도를 중시하며 빠르게 여러번 피드백 루프를 돌린다**
    - “작게 실패 → 작게 성공”을 반복하면서 **안정적인 개발 사이클**을 유지
- **하드코딩도 허용된다**
    - 초기에는 **하드코딩된 리턴값**이라도 괜찮다..?
    - 중요한 것은 테스트가 **성공했는지 아닌지**

앞선 예시를 이어서 봐보면

만들어둔 더하기에 대한 테스트를 통과하는 가장 최소한의 기능만 구현합니다. 

```swift
class Calculator {
    func add(_ a: Int, _ b: Int) -> Int {
        return 5 // 일단 통과 목적이니까 하드코딩도 가능
    }
}
```

이렇게요. 실제로는 값이 들어오지 않아서 리턴을 할수 없는 상황인데 테스트를 위해서 리턴을 만들어줍니다.

<aside>
❓

음,,,, 이래도 될까?? 실제 구현이 아무것도 없느데,,,????

</aside>

이건 TDD의 철학과 연결됩니다.

> TDD는 "정답을 바로 만드는 과정"이 아니라 "문제가 무엇인지 규명하고, 그 문제를 해결해가는 과정"입니다.
> 

테스트가 **통과하는지 여부**는 우리가 **요구사항을 만족하고 있는지**에 대한 피드백을 주는 과정입니다. 우리의 요구 사항인 Add는 두수를 더해서 더한 값을 리턴해준다! 이건만 만족시켜주면 되는거죠

이시점에서는 구체적이고 특화된 테스트코드 하나만 통과시키면 된다고 합니다

전 이사이클을 어떻게 이해했냐면요

레드에서 테스트코드로 작성한 명세서를 → 그린에서 코드의 실제 객체에 실체화하고 → 리팩터에서 구현을 한다

이런 사이클로 이해했습니다

즉  Green 단계는 기능을 "완벽하게" 만드는 것이 아니라, "테스트가 통과할 수 있게" 만드는 것이고 이 테스트가 요구하는 **최소 범위 내에서** 빠르게 성공을 달성하고, 그 결과를 바탕으로 **리팩토링과 일반화**를 진행하는 다음 단계로 가능게 중요한 단계인거죠!

### 3) Refactor: 기능은 유지하되 구조 개선

이제 이 단계에서는 청사진을 그려둔 객체에 살을 붙이는 작업을 합니다

**리펙터의 목적은**

- 중복 제거, 명확한 네이밍, 구조 개선 등을 통해 코드 품질 향상
- 기능은 그대로, 내부 구현만 변경
- 테스트는 계속 통과해야 함

여기서 전 테스트는 계속 통과해야함 이부분이 중요하다고 생각하는데요

예시를 이어서 봐보면

```swift
class Calculator {
    func add(_ a: Int, _ b: Int) -> Int {
        return a + b
    }
}
```

이렇게 Add의 구체적인 구현을 작성함으로써 우리가 구현할려던 기능을 구현할수 있게 되었습니다! 

그런데 구현과정중에 우리는 앞선 단계에서 만들어둔 테스트 상황을 항상 통과해야되는거잖아요 지금과 같이 리턴로직이 바뀌어도요, 그래서 미리 정의해둔 바운더리 내에서 개발을 하기 때문에 예측가능한 범주내의 오류나 에러를 처리할수 있게되는것 같습니다!

# XCTestExpectation

[XCTestExpectation | Apple Developer Documentation](https://developer.apple.com/documentation/xctest/xctestexpectation)

`XCTest`는 기본적으로 **동기**로직을 테스트하기 위해 설계되었습니다. 즉, 함수가 호출되면 곧바로 결과가 반환되고, 그 결과를 비교하는 식으로 테스트가 동작합니다.

하지만 현실 세계의 앱에서는 아래와 같은 **비동기** 작업이 많습니다

- `URLSession`을 통한 네트워크 요청
- 비동기 디스크 I/O
- DispatchQueue 비동기 작업
- Combine 또는 RxSwift의 비동기 스트림

이런 작업은 결과가 **나중에 도착**하므로 단순히 `XCTAssertEqual()` 같은 동기 비교로는 올바르게 테스트할 수 없겠죠?

## `XCTestExpectation`의 역할

이때 사용하는 것이 바로 `XCTestExpectation`입니다. 이 객체는 **"특정 비동기 이벤트가 발생했다"는 신호를 기다리는 장치**입니다.

### 흐름 요약:

1. 테스트 시작 시 **기대하는 이벤트**를 `XCTestExpectation(description:)`으로 생성합니다.
2. 비동기 작업이 완료되면 `expectation.fulfill()`을 호출하여 **이벤트가 발생했음을 알립니다**.
3. 테스트는 `wait(for:timeout:)`을 통해 **정해진 시간 동안 이벤트 발생을 기다립니다**.
4. 시간이 초과되거나 기대했던 이벤트가 발생하지 않으면 **테스트 실패**입니다.

코드로 봐봅시다

다음은 `URLSession`을 통한 네트워크 요청이 성공적으로 데이터를 받아오는지를 테스트하는 예시입니다.

```swift
import XCTest

final class APITests: XCTestCase {
    func test_fetchData_shouldReturnResponse() {
        // 1. expectation 생성 (설명 문자열은 디버깅용)
        let expectation = self.expectation(description: "API 호출이 완료되기를 기다림")

        let url = URL(string: "https://url이지롱.com/posts")!

        var receivedData: Data?

        // 2. 비동기 작업 실행
        URLSession.shared.dataTask(with: url) { data, response, error in
            receivedData = data

            // 3. 작업 완료 시 fulfill 호출
            expectation.fulfill()
        }.resume()

        // 4. expectation 대기
        wait(for: [expectation], timeout: 5.0)

        // 5. 결과 검증
        XCTAssertNotNil(receivedData, "API에서 데이터를 받아와야 합니다.")
    }
}

```

### 설명

- `expectation(description:)`: `"API 호출이 완료되기를 기다림"`이라는 설명을 가진 expectation을 생성합니다.
- `fulfill()`: 네트워크 콜백이 실행될 때 호출되며, **기대한 비동기 이벤트가 발생했음을 XCTest에게 알려줍니다.**
- `wait(for:timeout:)`: 최대 5초간 해당 expectation이 `fulfill()` 될 때까지 기다립니다.
    - 기다리는 동안 `fulfill()`이 호출되지 않으면 테스트는 실패합니다.
    

그러나 비동기 코드가 `fulfill()`을 **너무 빨리**, 혹은 **한 번도 호출되지 않으면** 테스트는 실패합니다. 

이를 통해 예상치 못한 네트워크 지연, 콜백 미호출 등의 문제도 빠르게 감지할 수 있습니다.

예를 들어, ViewModel에서 비동기 작업이 끝나고 UI 업데이트 콜백을 호출하는 경우 다음과 같이 씁니다.

```swift
func test_fetchMovies_updatesMovieList() {
    let expectation = self.expectation(description: "ViewModel이 영화 데이터를 업데이트함")
    let mockService = MockMovieService()
    let viewModel = MovieListViewModel(movieService: mockService)

    viewModel.onMoviesUpdated = {
        XCTAssertEqual(viewModel.movies.count, 2)
        expectation.fulfill() // 이때 테스트한테 값이 왔다는걸 알리겠죠?
    }

    viewModel.fetchMovies()

    wait(for: [expectation], timeout: 1.0)
}

```

이처럼 `XCTestExpectation`은 단순한 네트워크뿐 아니라 **ViewModel, UseCase, 비동기 클로저 호출 여부 확인** 등 다양한 곳에서 유용하게 사용됩니다.

| 개념 | 설명 |
| --- | --- |
| `XCTestExpectation` | 비동기 작업의 완료 여부를 기다리기 위한 객체 |
| `fulfill()` | 비동기 작업이 완료되었음을 명시적으로 알림 |
| `wait(for:timeout:)` | 정해진 시간 동안 fulfill을 기다림 |
| 실패 조건 | 콜백이 호출되지 않거나, 예상보다 오래 걸리면 실패로 간주됨 |

---

이처럼 `XCTestExpectation`은 XCTest로 **안정적이고 예측 가능한 비동기 테스트를 작성**하는 데 핵심적인 도구로써 사용되요,  비동기 흐름을 확실히 통제할 수 있게 해주기 때문에, 네트워크 로직이나 비동기 이벤트 기반 시스템에서는 필수적으로 사용됩니다

이제 이걸 실제로 적용해볼까요?

한번 영화 리스트 Api를 받아와서 테이블뷰에 뿌리는 기능을 구현할때 TDD관점에서 어떻게 할지 해봅시다!

| 고려 요소 | 설명 |
| --- | --- |
| 비즈니스 로직 분리 | 네트워크, 파싱, 뷰 업데이트 로직을 분리하여 테스트 가능하게 만듦 |
| 의존성 주입 | `URLSession` 등 외부 의존성을 주입 가능하게 하여 테스트 시 mocking |
| 비동기 처리 대응 | XCTestExpectation 사용 등으로 비동기 테스트 설계 |
| 뷰와 분리된 로직 테스트 | TableView는 직접 테스트하지 않음, 대신 뷰모델이나 usecase 등을 테스트함 |

이렇게 크게 4가지를 유의해서 코드를 작성합시다 그리고 해당 프로젝트의 객체는

- `Movie`: 영화 모델
- `MovieService`: URLSession으로 API 요청을 처리하는 서비스
- `MovieListViewModel`: 뷰에 표시할 데이터를 제공하는 뷰모델
- `MovieListViewController`: 테이블 뷰를 가진 뷰컨트롤러

이렇게 있다고 하면

이중에서도 뷰모델의

ViewModel이 주입된 서비스 객체로부터 받은 영화 데이터를 올바르게 저장하고, 데이터가 갱신되었음을 알리는 콜백을 정확히 호출하는지를 검증해봅시다

### 1. Red – 실패하는 테스트 작성

```swift
// MovieListViewModelTests.swift

import XCTest
@testable import MovieApp

final class MovieListViewModelTests: XCTestCase {
    func test_fetchMovies_shouldReturnMovieTitles() {
        let mockService = MockMovieService()
        let viewModel = MovieListViewModel(movieService: mockService)
        
        let expectation = self.expectation(description: "Movies fetched")
        
        viewModel.onMoviesUpdated = {
            XCTAssertEqual(viewModel.movies.map { $0.title }, ["Inception", "Interstellar"])
            expectation.fulfill()
        }
        
        viewModel.fetchMovies()
        
        waitForExpectations(timeout: 1.0, handler: nil)
    }
}
```

이 테스트는 아직 존재하지 않는 `MockMovieService`, `MovieListViewModel`, 그리고 `Movie` 모델에 의존하고 있기 때문에 현재 상태로는 컴파일조차 되지 않습니다. 하지만 이렇게 실패할 테스트를 먼저 작성함으로써 우리가 어떤 기능을 구현해야 하는지, 그리고 어떤 형태의 인터페이스를 가져야 하는지 명확하게 정의할 수 있습니다.

테스트의 흐름을 보면, `MockMovieService`는 테스트용 더미 데이터를 반환하는 역할을 합니다. `MovieListViewModel`은 그 데이터를 받아 `movies`라는 내부 배열에 저장하고,

 `onMoviesUpdated`라는 클로저를 통해 외부에 알립니다. 

이 콜백이 호출되었을 때, ViewModel이 가진 영화 제목 배열이 우리가 기대한 `["Inception", "Interstellar"]`과 일치하는지를 검증하고 있습니다. ⇒ 즉 실제로 호출되는지를 확인하는거죠!

### 2. Green

서비스 프로토콜 정의 및 Mock 구현

```swift
// MovieService.swift
protocol MovieServiceProtocol {
    func fetchMovies(completion: @escaping ([Movie]) -> Void)
}
```

`MovieServiceProtocol`은 실제 서비스와 모킹(mocking) 객체 모두에 공통으로 사용될 수 있도록 정의한 프로토콜입니다. 저번주에 다뤘던 DI를 통해 프로토콜을 통해 외부 의존성을 주입받을 수 있게 됩니다

그리고 이제 `MockMovieService`를 구현합니다.

```swift
// MockMovieService.swift
class MockMovieService: MovieServiceProtocol {
    func fetchMovies(completion: @escaping ([Movie]) -> Void) {
        let mockData = [
            Movie(title: "Inception"),
            Movie(title: "Interstellar")
        ]
        completion(mockData)
    }
}
```

`MockMovieService`는 실제 네트워크 요청 없이 테스트용 데이터를 즉시 반환하는 객체입니다. 이렇게 하면 실제 네트워크 환경에 구애받지 않고도 테스트를 수행할 수 있겠죠??

저번주 주제였던 mocking 쪽입니다.

그리고 이제 데이터를 정제할 ViewModel을 최소한으로만 구현합니다

```swift
// MovieListViewModel.swift
final class MovieListViewModel {
    var movies: [Movie] = []
    var onMoviesUpdated: (() -> Void)?

    private let movieService: MovieServiceProtocol

    init(movieService: MovieServiceProtocol) {
        self.movieService = movieService
    }

    func fetchMovies() {
        movieService.fetchMovies { [weak self] movies in
            self?.movies = movies
            self?.onMoviesUpdated?()
        }
    }
}
```

ViewModel은 외부로부터 주입받은 `movieService`를 통해 영화를 요청합니다. 요청이 완료되면 받은 데이터를 자신의 `movies` 배열에 저장하고, 콜백 클로저 `onMoviesUpdated`를 호출하여 외부에 변경을 알립니다.

여기서는 콜백을 사용했는데 보통 Rx같은 라이브러리를 통해서 손쉽게 구현하는것 같아요

이제 테스트에서 정의한 시나리오가 실제로 동작하며 테스트가 성공하게 됩니다.

앞서 테스트에서 목데이터에 있던 값들만 반환해도 성공하는걸로 작성해뒀죠?? 그래서 성공을 하게됩니다

### 3. Refactor – 구조 개선 및 실 구현 연결

기초 구조가 작동함을 확인했으니 이제 실제 API를 사용하는 네트워크 서비스 객체를 구현해봅니다.

MovieService 실제 구현

```swift
// URLMovieService.swift
class URLMovieService: MovieServiceProtocol {
    func fetchMovies(completion: @escaping ([Movie]) -> Void) {
        guard let url = URL(string: "https://url/movies") else {
            completion([])
            return
        }

        URLSession.shared.dataTask(with: url) { data, response, error in
            guard let data = data,
                  let movies = try? JSONDecoder().decode([Movie].self, from: data) else {
                completion([])
                return
            }
            completion(movies)
        }.resume()
    }
}
```

이 서비스 클래스는 실제 API로부터 JSON 데이터를 받아 `Movie` 배열로 디코딩한 후 콜백으로 결과를 전달합니다. 

### 뷰컨트롤러와 연결

```swift
// MovieListViewController.swift
class MovieListViewController: UIViewController, UITableViewDataSource {
    private let tableView = UITableView()
    private var viewModel: MovieListViewModel!

    override func viewDidLoad() {
        super.viewDidLoad()
        viewModel = MovieListViewModel(movieService: URLMovieService())
        setupTableView()
        bindViewModel()
        viewModel.fetchMovies()
    }

    private func setupTableView() {
        tableView.dataSource = self
        view.addSubview(tableView)
        tableView.frame = view.bounds
    }

    private func bindViewModel() {
        viewModel.onMoviesUpdated = { [weak self] in
            DispatchQueue.main.async {
                self?.tableView.reloadData()
            }
        }
    }

    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return viewModel.movies.count
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = UITableViewCell()
        cell.textLabel?.text = viewModel.movies[indexPath.row].title
        return cell
    }
}
```

ViewController는 `MovieListViewModel`을 사용하여 데이터를 가져오고, `onMoviesUpdated`를 통해 데이터 갱신이 일어났을 때 테이블 뷰를 다시 로드합니다. `UITableViewDataSource` 프로토콜을 통해 영화 리스트를 화면에 표시하며, 각 셀에는 영화 제목이 보여집니다.
