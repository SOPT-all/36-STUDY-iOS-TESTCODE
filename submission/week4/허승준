## 1. TDD 사이클 (Red-Green-Refactor)

### 1) RED : (실패하는) 테스트 코드를 작성하라

✅ 테스트 코드를 작성하면, 해당 코드에 알맞은 객체나 속성 등이 정의되어있지 않기 때문에 실패할 것이다

🎈**예시 코드**

```
import XCTest
class CalculatorTests: XTestCase {
    func 두_수를_더하여_합을_반환한다() {
        let calculator = Calculator()
        let result = calculator.add(3, 7)
        XCTAssertEqual(result, 10)
    }
}
```

🎈**현재는 Calculator 클래스(구조체)와 add 메서드를 구현하지 않은 상태이므로, 위 테스트는 무조건 실패**


### 2) GREEN : 테스트를 통과하는 최소 코드를 작성하라

✅ 테스트 코드를 통과시키기 위한 최소한의 코드를 작성한다

🎈**예시 코드**

```
class Calculator {
    func add(_ a: Int, _ b: Int) {
        return 10
    }
}
```

🎈**테스트는 통과! But 무조건 10을 리턴하기 때문에 리팩토링 필요**


### 3) REFACTOR : 리팩토링

✅ 항상 테스트를 통과할 수 있도록 코드를 리팩토링한다

🎈**예시 코드**

```
class Calculator {
    func add(_ a: Int, _ b: Int) {
        return a + b
    }
}
```

---
## 2. 비동기 테스트 XCTestExpectation

### 1) 테스트하기 어려운 코드란 무엇일까?

✅ **테스트 시마다 결과가 달라질 수 있는 경우**

🎈**예시 코드 (잘못된 예시)**


🎈**예시 코드 (올바른 예시 : 동작 분리)**


✅ **전역 상태를 사용하는 경우**

🎈 **전역 상태 사용**


🎈 **이렇게 고쳐보자**



✅ **뷰와 로직이 결합된 경우**

🎈 **뷰와 로직의 결합**



🎈 **이렇게 고쳐보자**


### 3) 테스트 가능한 코드 구조의 핵심 원칙

✅ **단일 책임 원칙**

🎈객체는 **단 하나의 책임**만 가져야 한다<br>
🎈평가 척도 : 기능 수정 시 파급 효과<br>
🎈즉, 단일 책임 원칙은 모듈이 변경되는 이유가 1가지여야 한다는 것!


✅ **SOLID 원칙**

🎈**S : 단일 책임 원칙**
  - 이미 다루었죠?

🎈**O : 개방-폐쇄 원칙**

🎈**L : 리스코프 치환 원칙**
  

🎈**I : 인터페이스 분리 원칙**

🎈**D : 의존 역전 원칙**
  - 상위 모듈은 하위 모듈에 의존해서는 안 된다
  - 상위 모듈과 하위 모듈 모두 추상화된 인터페이스(프로토콜)에 의존해야 한다
  - 예시 코드

