# 2주차

> • GWT 패턴 - BBD 및 AAA 패턴
• Test Assertions
-  Boolean Assertions
> 

## 1. GWT 패턴 – BDD 및 AAA 패턴

### GWT란 무엇인가?

**GWT(Given-When-Then)** 패턴은 Behavior Driven Development (BDD)에서 파생된 테스트 작성 구조로, 테스트 케이스를 작성할 때 **인간이 읽기 좋은 언어로 시나리오처럼** 작성하는 방식을 의미합니다.

즉, 테스트코드를 작성할때 가독성을 위한 패턴으로 전 이해했습니다.

이 구조는 단순히 기능이 잘 작동하는지를 확인하는 것이 아니라, **기능이 어떤 상황에서 어떻게 동작해야 하는지를 '행동 중심으로' 기술**한다는 점에서 일반적인 단위 테스트 구조(AAA)와 구분됩니다.

### GWT의 구성요소

- **Given**: 테스트 전의 상태를 준비합니다. (ex. 객체 생성, 값 설정)
- **When**: 테스트 대상인 동작을 수행합니다. (ex. 함수 호출)
- **Then**: 결과를 검증합니다. (ex. XCTAssert 사용)

### AAA의 구성요소

- **Assignment (준비)**

테스트 코드를 실행하기 전에 시스템이 적절한 상태에 있도록함. (ex. 객체생성, 사전 준비에 필요한 api 호출 등)

- **Act (실행)**

테스트 코드를 실행. 

- **Assert (단언)**

실행한 코드가 개발자가 기대한 대로 동작하는지 확인하는 요소. 예를들면 실행한 코드의 반환값 검사, 새로운 객체의 상태 검사가 속함.

### AAA(Arrange-Act-Assert)와의 관계

GWT는 AAA 패턴과 본질적으로 같은 구조입니다. 다만 **표현 관점이 다르다고 느꼇습니다.**

| 패턴 | 목적 | 강조점 |
| --- | --- | --- |
| AAA | 단위 테스트 | 개발자 중심의 동작 검증 |
| GWT | BDD 기반 테스트 | **행동 중심**, **가독성 중심**, **협업 중심** |

---

### 왜 GWT 패턴을 써야 할까?

앞서 이야기 했듯이 GWT패턴은 3자와의 소통을 위한 패턴으로 이해했는데요. 크게 4가지의 패턴사용의 이점에 대해 조사해왔습니다.

1. **가독성 향상**
    
    누구나 읽기 쉬운 구조로 테스트의 의도를 명확히 전달할 수 있습니다. 특히 비개발자와 협업 시 유용할거 같다고 생각합니다.
    
    3가지 요소에 대해서 정해진 규칙대로 테스트시나리오가 작성되어지기 때문에 코드를 통해 시나리오를 이해할수 있게 됩니다.
    
2. **협업에 유리**
    
    비즈니스 분석가, 기획자도 쉽게 이해할 수 있는 시나리오 기반 작성이 가능하여 요구사항 기반 테스트로 연결할수 있게되1니다.
    
3. **중복 방지 및 구조화**
    
    테스트 코드 간 역할을 명확히 분리하므로, 코드 중복을 줄이고 구조적인 테스트 작성이 가능해집니다.
    
    이부분도 가독성 부분과 연결되느는 부분이라고 생각하는데요, 아무리 잘 협업한다고 해도, 테스트코드의 중복은 어쩔수 없이 일어 날수도 있을거 같습니다. 그래서 작성하는 개발자가 빠르게 이해하고, 잘 반영할수 있도록 도움을 준다는점이 중요할거 같습니다!
    
4. **테스트 의도 파악이 용이**
    
    이부분도 가독성과 연결되는 부분으로 문제가 발생했을 때 **무엇을 테스트했는지, 어떤 맥락에서 실패했는지 빠르게 이해할 수 있습니다.**
    

## GWT / AAA 패턴 예제 코드

---

### 예제 1 – 계산기 덧셈 기능 테스트

테스트코드의 국룰 예제 계산기예제를 가지고왔습니다. 

더하기 로직에 대해서 잘 더해지는지 확인하기 위한 간단한 테스트코드를 짜봤습니다.

```swift
func test_addTwoNumbers_returnsSum() {
    // Given (Arrange)
    let calculator = Calculator()
    let a = 10
    let b = 20

    // When (Act)
    let result = calculator.add(a, b)

    // Then (Assert)
    XCTAssertEqual(result, 30)
}
```

- **GWT 관점**
    - Given: `calculator`, `a`, `b`를 설정해서 주어진 값을 세팅하고,
    - When: `calculator.add(a, b)`를 호출
    - Then: 결과가 `30`인지 검증
- **AAA 관점**
    - Arrange: 필요한 인스턴스를 구성 (`Calculator`, 값들)
    - Act: add 연산 수행
    - Assert: 결과값이 기대값과 동일한지 확인

### 예제 2 – 로그인 여부 확인

---

 이 테스트는 사용자의 행동(로그인)에 대한 기대 결과를 검증하고 있으므로 **BDD 성격**이 잘 드러 나도록 한번 예시 코드를 작성해봤는데,

```swift
func test_login_setsIsLoggedInToTrue() {
    // Given
    let userManager = UserManager()

    // When
    userManager.login(email: "test@abc.com", password: "1234")

    // Then
    XCTAssertTrue(userManager.isLoggedIn)
}

```

- **GWT 관점**
    - Given: 초기 상태에서 로그인되지 않은 `userManager` 생성
    - When: `login()` 함수 실행
    - Then: `isLoggedIn == true` 여부 확인
- **AAA 관점**
    - Arrange: 테스트에 필요한 객체(userManager) 구성
    - Act: 메서드 실행
    - Assert: 불리언 값 검증

---

### 예제 3 – 초기 상태 확인

상태를 확인하는 경우에대해서는 GWT중 when이 빠질수도 있을거 같아서 **GWT에서 When이 생략된 구조**로 테스트 상황 만들고 코드 작성해봤습니다.

```swift
func test_initialIsLoggedInIsFalse() {
    // Given
    let userManager = UserManager()

    // Then
    XCTAssertFalse(userManager.isLoggedIn)
}

```

- **GWT 관점**
    - Given: 아무 작업도 수행되지 않은 초기 상태의 `userManager`
    - When: 없음 (상태 확인만 수행)
    - Then: `isLoggedIn`이 `false`인지 검증
- **AAA 관점**
    - Arrange: 기본 인스턴스 생성
    - Act: 없음
    - Assert: 속성 값이 기대값과 일치하는지 확인

## 마무리 정리

---

사실 정리하면서 AAA와 GWT가 정확히 뭐가다른지에 대해서 아직도 명확하게 답을 내리지 못했습니다. GWT의 요소들이랑 AAA의 요소들이 일대일로 대응되는거 같다는 생각이 들지만, 지향점이 조금은 다르다는 차이점만 느낄수 있었습니다.  

- GWT는 테스트를 “이 상황에서 이렇게 행동하면 이렇게 되어야 한다”라는 시나리오로 표현함으로써, **의도 중심 테스트**가 가능하게 해주는 패턴이고
- AAA는 조금더 개발자 친화적인 방식으로 구성된다?

라는 차이점으로 인식했습니다. 

다만 협업시 테스트 코드 작성 시 GWT 패턴을 의식하고 작성하면, **가독성**, **문서화 효과**, **협업 효율**을 모두 챙길 수 있을거 같아 활용해볼 계획입니다.

---

## 2. Test Assertions

**Test Assertion**이란, 테스트의 실제 결과(actual)가 기대한 결과(expected)와 일치하는지를 검증하기 위한 **조건문 기반의 검사 도구**입니다.

Swift에서는 `XCTest` 프레임워크를 통해 구현할수 있으면 내장된 `XCTAssert`로 시작하는 여러 함수들을 통해 구현할수 있습니다.

테스트 코드는 결국 "기대한 대로 동작하는가?"를 확인하는 것이며, Assertion은 이 질문에 대한 **검증 수단인 것이지요**

`XCTest`에서 제공하는 검증 도구인 Assertion은 테스트 대상의 결과를 기대값과 비교하는 도구입니다.

여러가지 종류가 있어서 각 상황에 맞춰 사용하면됩니다.

### 주요 종류와 설명

- `XCTAssertEqual(a, b)`: a와 b가 같은지 비교
- `XCTAssertNotEqual(a, b)`: a와 b가 다른지 확인
- `XCTAssertTrue(condition)`: condition이 true인지 확인
- `XCTAssertFalse(condition)`: condition이 false인지 확인
- `XCTAssertNil(value)`: 값이 nil인지 확인
- `XCTAssertNotNil(value)`: 값이 nil이 아닌지 확인
- `XCTFail(message)`: 무조건 실패시킴
- `XCTAssertThrowsError(expression)`: 오류 발생 여부 확인
- `XCTAssertNoThrow(expression)`: 오류가 발생하지 않아야 함

### 예제 1 - 로그인 결과 검증

```swift
func test_login_setsUserObject() {
    let manager = UserManager()
    manager.login(email: "test@abc.com", password: "pass")

    XCTAssertNotNil(manager.currentUser)
    XCTAssertEqual(manager.currentUser?.email, "test@abc.com")
}

```

1. 목적

- 사용자가 로그인을 수행했을 때, `UserManager` 내부의 `currentUser` 객체가 정상적으로 설정되었는지 확인한다.

2. 사용된 Assertions

- `XCTAssertNotNil(manager.currentUser)`
    
    → `login()` 이후 `currentUser`가 **nil이 아니어야** 함을 보장하기때문에 nil을 확인하기 위한 어썰션이 사용되었다. 즉, **로그인이 성공했다는 증거**로 user가 생성되었는지를 확인하는 것이다.
    
- `XCTAssertEqual(manager.currentUser?.email, "test@abc.com")`
    
    → `currentUser`가 정확한 이메일을 가지고 있는지 확인하여, **데이터 무결성**을 검증한다.
    

3. 검증 포인트

- 객체 생성 여부 (`nil` 검증)
- 객체 내부 상태 검증 (`email` 속성 확인)

### 예제 2 - 예외 발생 여부 검증

```swift
func test_invalidLogin_throwsError() {
    let manager = UserManager()

    XCTAssertThrowsError(try manager.login(email: "", password: "")) { error in
        XCTAssertEqual(error as? LoginError, LoginError.invalidCredentials)
    }
}

```

1. 목적

- 잘못된 로그인 입력인 email/password가 비어있는 경우에 대해, `login()` 함수가 적절하게 에러를 던지는지 검증하는 테스트코드입니다.

2. 사용된 Assertions

- `XCTAssertThrowsError`
    
    → 클로저 내의 코드를 실행했을 때 **에러가 발생해야 테스트가 통과**됨.
    
    → BDD나 보안 측면에서 "실패도 예외처리를 통해 안전하게 다룬다"는 관점의 테스트로써 사용됩니다.
    
- `XCTAssertEqual(error as? LoginError, LoginError.invalidCredentials)`
    
    실제로 던져진 오류가 기대한 `LoginError.invalidCredentials`와 같은지 확인함하는 어썰션입니다
    
    → 다양한 오류 타입이 있을 수 있기 때문에 **정확한 에러 종류를 판별**하는 데 사용되어 집니다.
    

3. 검증 포인트

- 특정 조건에서 **예외가 발생하는가**
- 예외가 발생한다면, **그 예외는 기대한 예외인가**

### 예제 3 - 실패 강제

```swift
func test_failureExample() {
    XCTFail("이 테스트는 실패하기 위해 작성되었습니다.")
}

```

1. 목적

- 이 테스트는 **의도적으로 실패하게 작성된 테스트**로, 주로 다음의 경우에 사용된다고 합니다
    - 아직 구현되지 않은 테스트 케이스에 대한 마커로 사용 (예: TDD 개발 중)
    - 실패를 의도적으로 유도하여 테스트 환경이나 로직을 검증하는 경우

2. 사용된 Assertions

- `XCTFail("메시지")`
    
     어떤 조건이든 상관없이 무조건 테스트를 실패시킴.
    
    → 메시지를 함께 주면 실패 원인을 테스트 로그에서 명확히 파악할 수 있다.
    

3. 검증 포인트

- 실제로는 **검증보다는 알림용으로 사용**됨.
- 테스트를 작성하고 나중에 로직 구현 후 성공 테스트로 바꾸는 **TDD 루틴에 자주 사용**됨.

이테스트를 조사하면서 조금 의외였는데요, 이 테스트는 실질적인 검증보다는, **“이 테스트가 아직 작성되지 않았습니다”** 혹은 **“이 조건에서는 반드시 실패해야 합니다”** 라는 시그널을 주기 위한 도구로써 주로 사용된다고 합니다.

---

## 3. Boolean Assertions

`Boolean Assertion`은 **참(true)/거짓(false)** 조건을 검증하기 위한 단정문입니다. `XCTest`에서는 다음 두 가지가 가장 대표적으로 사용되어지는데

- `XCTAssertTrue(expression)`
    - 주어진 표현식이 **true**여야 테스트가 통과합니다.
    - 표현식이 false인 경우 테스트는 실패합니다.
- `XCTAssertFalse(expression)`
    - 주어진 표현식이 **false**여야 테스트가 통과합니다.
    - 표현식이 true인 경우 테스트는 실패합니다.

이 두 가지를 통해 

- 어떤 상태가 켜짐/꺼짐 상태인지 확인할 때
- 특정 조건문이 참/거짓인지 확인할 때
- 전환, 활성화, 플래그 등의 결과를 검증할 때

이 경우에 대한 테스트를 추가할수 있게됩니다. 

### 예제 1 - 초기 상태가 false인지 검증

```swift
func test_initialToggleState_isOff() {
    let toggle = ToggleSwitch()
    XCTAssertFalse(toggle.isOn)
}

```

**설명**

- **Given**: 새로 생성된 `ToggleSwitch` 객체는 기본적으로 꺼진 상태여야 함
- **When**: 아무 동작도 하지 않음
- **Then**: `isOn` 속성은 `false`여야 함

**검증 포인트**

- 기본 상태가 명확하게 정의되어 있어야 한다는 것을 테스트함
- 개발자가 `ToggleSwitch`의 초기 상태를 실수로 true로 설정하지 않았는지를 검증하는 코드입니다.

### 예제 2 - 상태 전환 후 true인지 확인

```swift
func test_toggleSwitch_shouldBeOnAfterToggle() {
    let toggle = ToggleSwitch()
    toggle.toggle()
    XCTAssertTrue(toggle.isOn)
}

```

**설명**

- **Given**: 꺼진 상태의 토글 스위치
- **When**: `toggle()` 메서드를 실행하여 상태를 전환
- **Then**: `isOn` 값이 `true`가 되어야 함

**검증 포인트**

- 상태 전환 로직이 정상 동작하는지를 확인함
- 메서드 실행 후 상태가 의도한 대로 바뀌었는지를 검증함

### 예제 3 - 조건식 검증

```swift
func test_numberIsEven_shouldBeTrueForEvenNumber() {
    let number = 10
    let isEven = number % 2 == 0
    XCTAssertTrue(isEven)
}

```

**설명**

- **Given**: 정수 `number = 10`
- **When**: `% 2 == 0` 조건으로 짝수 여부를 판단
- **Then**: `isEven`은 true여야 하므로, `XCTAssertTrue(isEven)` 사용

**검증 포인트**

- 비즈니스 로직 내 짝수 조건 검사를 검증하는 데 사용 가능
- 단순한 수식이지만, 이 조건이 추후에 후속 로직의 핵심 분기 기준이 될 수 있기때문에 검증이 필요한 경우 사용되어 집니다
